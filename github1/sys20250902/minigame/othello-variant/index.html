<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>オセロ・点対称ペア欠損（中央4以外）</title>
  <style>
    :root{
      --bg:#0b1220; --fg:#e5ecff; --muted:#93a4c8; --card:#0f172a; --accent:#22d3ee; --border:#1f2a44;
      --g1:#0e7a39; --g2:#0a5e2c; --grid:#083b1c;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --accent:#059669; --border:#e2e8f0;
        --g1:#4ca96b; --g2:#2f894e; --grid:#1a5d34;
      }
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
    }
    header{
      position: sticky; top:0; z-index: 1;
      display:flex; justify-content:space-between; align-items:center; gap:16px;
      padding:12px 16px; border-bottom:1px solid var(--border); background: color-mix(in oklab, var(--card), var(--bg) 20%);
    }
    header .left{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .right{ font-size:.95rem; color:var(--muted); display:flex; gap:10px; align-items:center; }
    .btn{ background:var(--accent); color:white; border:0; padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
    .chk{ font-size:.9rem; color:var(--muted); user-select:none; }
    .badge{ padding:.25rem .5rem; border-radius:999px; border:1px solid var(--border); background: color-mix(in oklab, var(--card), var(--bg) 25%); }

    main.wrap{
      max-width:1000px; margin:0 auto; padding:16px; display:grid; gap:16px;
      grid-template-columns: minmax(280px, 1fr) 320px;
    }
    @media (max-width: 860px){ main.wrap{ grid-template-columns: 1fr; } }

    .board{
      display:grid; grid-template-columns: repeat(8, minmax(36px, 1fr));
      width:100%; max-width: min(92vw, 640px); aspect-ratio: 1 / 1;
      border-radius:14px; overflow:hidden; border:2px solid var(--grid);
      background: var(--grid);
      user-select: none; touch-action: manipulation;
      box-shadow: inset 0 0 0 6px var(--grid);
    }
    .cell{
      position: relative; display:flex; justify-content:center; align-items:center; cursor:pointer;
      background: var(--g1);
      box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--grid), black 20%);
    }
    .cell.alt{ background: var(--g2); }
    .cell.blocked{
      background:
        repeating-linear-gradient(45deg, rgba(0,0,0,.35) 0 6px, rgba(255,255,255,.15) 6px 12px),
        var(--g2);
      cursor:not-allowed;
    }
    .disc{
      width: 70%; height: 70%;
      border-radius: 999px;
      box-shadow: inset 0 1.5vmin 0 rgba(255,255,255,.25),
                  inset 0 -1.5vmin 0 rgba(0,0,0,.25),
                  0 2px 4px rgba(0,0,0,.35);
    }
    .disc.black{ background: #111; }
    .disc.white{ background: #f7fafc; }

    .cell.move::before{
      content:''; position:absolute; width:22%; height:22%; border-radius:999px;
      box-shadow: 0 0 0 2px rgba(34,211,238,.9), inset 0 0 0 2px rgba(34,211,238,.9);
      background: rgba(34,211,238,.15);
    }
    .cell.selected{ outline: 3px solid #f59e0b; outline-offset:-3px; }
    .coord{ position:absolute; font-size:10px; opacity:.8; color:rgba(255,255,255,.85); mix-blend-mode: overlay; text-shadow: 0 1px 2px rgba(0,0,0,.6);}
    .coord.x{ left:4px; top:2px; }
    .coord.y{ right:4px; bottom:2px; }

    .panel{
      background: var(--card); border:1px solid var(--border); border-radius:14px; padding:12px;
    }
    .panel h3{ margin:.2rem 0 0.6rem; font-size:1rem; }
    .panel ul{ margin:.2rem 0 .2rem 1.2rem; color:var(--muted); font-size:.95rem; }
    .legend{ margin-top:.6rem; display:flex; gap:12px; color:var(--muted); font-size:.9rem; align-items:center; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: color-mix(in oklab, var(--card), var(--bg) 30%); padding:.1rem .35rem; border-radius:6px; border:1px solid var(--border); }
    .score{ display:flex; gap:10px; align-items:center; }
    .score .dot{ width:14px; height:14px; border-radius:999px; display:inline-block; vertical-align:middle; }
    .dot.black{ background:#111; box-shadow: inset 0 0 0 1px rgba(255,255,255,.25); }
    .dot.white{ background:#f7fafc; box-shadow: inset 0 0 0 1px rgba(0,0,0,.25); }

    .won{ color:#16a34a; font-weight:700; }
    .pass{ color:#f59e0b; }
    .blocked-info{ color:#eab308; }
  </style>
</head>
<body>
  <header>
    <div class="left">
      <button id="newGameBtn" class="btn">新しい対局</button>
      <label class="chk"><input type="checkbox" id="showCoords" checked> 座標表示</label>
      <span class="badge">中央4以外の1マスとその点対称の1マスを「使用不可」</span>
    </div>
    <div class="right">
      <div class="score">
        <span class="dot black"></span><span id="blackCount">2</span>
        <span> - </span>
        <span class="dot white"></span><span id="whiteCount">2</span>
      </div>
      <span id="blockedInfo" class="blocked-info"></span>
      <span id="turnInfo">黒の手番</span>
    </div>
  </header>

  <main class="wrap">
    <div id="board" class="board" aria-label="オセロ盤 8x8"></div>
    <aside class="panel">
      <h3>ルール（このバリアント）</h3>
      <ul>
        <li>通常のオセロのルール。</li>
        <li>開始時に<strong>中央4マス以外で選んだ1マス</strong>と、<strong>その点対称位置の1マス</strong>の計2マスが「使用不可」になる（置けない／ラインは遮断される）。</li>
        <li>先手は黒。置けるマスは水色の点で表示。</li>
        <li>どちらも置けない場合はゲーム終了。枚数の多い方が勝ち。</li>
      </ul>
      <div class="legend">
        <span><span class="dot black"></span> 黒</span>
        <span><span class="dot white"></span> 白</span>
        <span class="kbd">N</span> 新しい対局
      </div>
    </aside>
  </main>

  <script>
  (function(){
    'use strict';
    function ready(fn){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', fn, {once:true}); } else { fn(); } }

    ready(() => {
      const boardEl = document.getElementById('board');
      const newBtn = document.getElementById('newGameBtn');
      const showCoordsChk = document.getElementById('showCoords');
      const turnInfo = document.getElementById('turnInfo');
      const blackCountEl = document.getElementById('blackCount');
      const whiteCountEl = document.getElementById('whiteCount');
      const blockedInfoEl = document.getElementById('blockedInfo');

      if(!boardEl){ console.error('[othello] #board not found'); return; }

      const BLACK='B', WHITE='W', BLOCK='#';
      const size = 8;

      const state = {
        board: emptyBoard(),
        turn: BLACK,
        blocked: [], // [{x,y}, {x,y}]
        gameOver: false,
        lastPassSide: null,
      };

      function emptyBoard(){
        return Array.from({length:size}, ()=> Array.from({length:size}, ()=> null));
      }
      function place(b,x,y,val){ b[y][x] = val; }
      function inBoard(x,y){ return x>=0 && x<8 && y>=0 && y<8; }
      function otherSide(s){ return s===BLACK?WHITE:BLACK; }
      function mirror(x,y){ return {x: 7-x, y: 7-y}; }

      function startNewGame(){
        state.board = emptyBoard();
        state.turn = BLACK;
        state.gameOver = false;
        state.lastPassSide = null;

        // 初期配置（中央4）
        place(state.board,3,3,WHITE);
        place(state.board,4,4,WHITE);
        place(state.board,4,3,BLACK);
        place(state.board,3,4,BLACK);

        // 欠損マス（点対称ペア）
        state.blocked = pickBlockedPair();
        for(const c of state.blocked){
          place(state.board, c.x, c.y, BLOCK);
        }

        render();
      }

      function pickBlockedPair(){
        const central = new Set(['3,3','4,4','4,3','3,4']);
        const candidates = [];
        for(let y=0;y<8;y++){
          for(let x=0;x<8;x++){
            const key = `${x},${y}`;
            if(!central.has(key)) candidates.push({x,y});
          }
        }
        const first = candidates[(Math.random()*candidates.length)|0];
        const second = mirror(first.x, first.y);
        // 念のため中央4の安全確認（firstが中央ならsecondも中央だが、候補から除外済）
        return [first, second];
      }

      function coordToLabel(x,y){
        const file = String.fromCharCode(65 + x); // A..H
        const rank = 8 - y;
        return `${file}${rank}`;
      }

      function countDiscs(){
        let b=0,w=0;
        for(let y=0;y<8;y++){
          for(let x=0;x<8;x++){
            const v = state.board[y][x];
            if(v===BLACK) b++;
            else if(v===WHITE) w++;
          }
        }
        return {b,w};
      }

      function legalMoves(side){
        const moves = [];
        for(let y=0;y<8;y++){
          for(let x=0;x<8;x++){
            if(state.board[y][x]!==null) continue; // 空きマスのみ（BLOCKは不可）
            const flips = getFlips(x,y,side);
            if(flips.length) moves.push({x,y,flips});
          }
        }
        return moves;
      }

      function getFlips(x,y,side){
        if(!inBoard(x,y)) return [];
        const here = state.board[y][x];
        if(here !== null) return []; // occupied or blocked
        const opp = otherSide(side);
        const flips = [];
        const dirs = [-1,0,1];
        for(const dx of dirs){
          for(const dy of dirs){
            if(dx===0 && dy===0) continue;
            let i=x+dx, j=y+dy;
            let line = [];
            if(!inBoard(i,j)) continue;
            const first = state.board[j][i];
            if(first !== opp){ continue; }
            line.push({x:i,y:j});
            i+=dx; j+=dy;
            while(inBoard(i,j)){
              const v = state.board[j][i];
              if(v === opp){
                line.push({x:i,y:j});
                i+=dx; j+=dy;
                continue;
              }
              if(v === side){
                flips.push(...line);
                break;
              }
              // v が null または BLOCK の場合は打ち切り
              break;
            }
          }
        }
        return flips;
      }

      function applyMove(x,y,side,flips){
        place(state.board, x, y, side);
        for(const f of flips){
          place(state.board, f.x, f.y, side);
        }
      }

      function handleCellClick(e){
        if(state.gameOver) return;
        const x = parseInt(e.currentTarget.dataset.x,10);
        const y = parseInt(e.currentTarget.dataset.y,10);
        if(state.board[y][x] !== null) return;

        const flips = getFlips(x,y,state.turn);
        if(!flips.length) return;

        applyMove(x,y,state.turn,flips);

        const next = otherSide(state.turn);
        const nextMoves = legalMoves(next);
        if(nextMoves.length){
          state.turn = next;
          state.lastPassSide = null;
        }else{
          const curMoves = legalMoves(state.turn);
          if(curMoves.length){
            state.lastPassSide = next; // 相手がパス
          }else{
            state.gameOver = true; // どちらも置けない
            state.lastPassSide = null;
          }
        }
        render();
      }

      function render(){
        boardEl.innerHTML = '';
        for(let y=0;y<8;y++){
          for(let x=0;x<8;x++){
            const cell = document.createElement('div');
            cell.className = 'cell' + (((x+y)&1)?' alt':'');
            cell.dataset.x = x;
            cell.dataset.y = y;

            if(showCoordsChk.checked){
              const cx = document.createElement('div');
              cx.className='coord x';
              cx.textContent = String.fromCharCode(65 + x);
              const cy = document.createElement('div');
              cy.className='coord y';
              cy.textContent = (8 - y);
              cell.appendChild(cx); cell.appendChild(cy);
            }

            const v = state.board[y][x];
            if(v === BLACK || v === WHITE){
              const d = document.createElement('div');
              d.className = 'disc ' + (v===BLACK?'black':'white');
              cell.appendChild(d);
            } else if (v === BLOCK){
              cell.classList.add('blocked');
              const mark = document.createElement('div');
              mark.style.position='absolute';
              mark.style.inset='0';
              mark.style.display='flex';
              mark.style.alignItems='center';
              mark.style.justifyContent='center';
              mark.style.color='rgba(255,255,255,.9)';
              mark.style.fontSize='clamp(16px, 4.5vw, 28px)';
              mark.style.textShadow='0 1px 2px rgba(0,0,0,.5)';
              mark.textContent='×';
              cell.appendChild(mark);
            } else {
              if(!state.gameOver){
                const flips = getFlips(x,y,state.turn);
                if(flips.length) cell.classList.add('move');
              }
            }

            cell.addEventListener('click', handleCellClick);
            boardEl.appendChild(cell);
          }
        }

        const {b,w} = countDiscs();
        blackCountEl.textContent = b;
        whiteCountEl.textContent = w;

        const [c1,c2] = state.blocked;
        blockedInfoEl.textContent = (c1 && c2)
          ? `使用不可: ${coordToLabel(c1.x, c1.y)}・${coordToLabel(c2.x, c2.y)}`
          : '';

        if(state.gameOver){
          let msg = 'ゲーム終了: ';
          const res = b===w ? `引き分け (${b} - ${w})` : (b>w ? `黒の勝ち (${b} - ${w})` : `白の勝ち (${b} - ${w})`);
          msg += res;
          turnInfo.textContent = msg;
          turnInfo.classList.add('won');
        }else{
          let msg = (state.turn===BLACK ? '黒の手番' : '白の手番');
          if(state.lastPassSide){
            msg += state.lastPassSide===BLACK ? '（黒はパス）' : '（白はパス）';
            turnInfo.classList.add('pass');
          }else{
            turnInfo.classList.remove('pass');
          }
          turnInfo.textContent = msg;
          turnInfo.classList.remove('won');
        }
      }

      function shuffleInPlace(a){
        for(let i=a.length-1;i>0;i--){
          const j=(Math.random()*(i+1))|0;
          [a[i],a[j]]=[a[j],a[i]];
        }
        return a;
      }

      // Controls
      newBtn.addEventListener('click', startNewGame);
      showCoordsChk.addEventListener('change', render);
      window.addEventListener('keydown', (e)=>{
        if(e.key==='n' || e.key==='N'){ startNewGame(); }
      });

      startNewGame();
    });
  })();
  </script>
</body>
</html>
