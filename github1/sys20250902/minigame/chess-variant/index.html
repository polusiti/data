<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>チェス・線対称ランダム配置（Q/K固定・ポーン含む）</title>
  <style>
    :root{
      --bg:#0b1220; --fg:#e5ecff; --muted:#93a4c8; --card:#0f172a; --accent:#22d3ee; --border:#1f2a44;
      --light:#f0f4ff; --dark:#5b7dbd;
    }
    @media (prefers-color-scheme: light){
      :root{ --bg:#f8fafc; --fg:#0f172a; --muted:#475569; --card:#ffffff; --accent:#0891b2; --border:#e2e8f0;
             --light:#e8edf8; --dark:#7a9ad6; }
    }
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", Arial, sans-serif;
    }
    header{
      position: sticky; top:0; z-index: 1;
      display:flex; justify-content:space-between; align-items:center; gap:16px;
      padding:12px 16px; border-bottom:1px solid var(--border); background: color-mix(in oklab, var(--card), var(--bg) 20%);
    }
    header .left{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    header .right{ font-size:.9rem; color:var(--muted); }
    .btn{ background:var(--accent); color:white; border:0; padding:8px 12px; border-radius:10px; font-weight:700; cursor:pointer; }
    .chk{ font-size:.9rem; color:var(--muted); user-select:none; }

    main.wrap{
      max-width:1000px; margin:0 auto; padding:16px; display:grid; gap:16px;
      grid-template-columns: minmax(280px, 1fr) 320px;
    }
    @media (max-width: 860px){ main.wrap{ grid-template-columns: 1fr; } }

    .board{
      display:grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(8, 1fr); /* 行も明示して各マスを完全均等に（駒有無でサイズが変わらない） */
      width:100%; max-width: min(92vw, 640px); aspect-ratio: 1 / 1;
      border-radius:14px; overflow:hidden; border:1px solid var(--border);
      background: var(--border);
      user-select: none;
      touch-action: manipulation;
    }
    .cell{
      position: relative; display:flex; justify-content:center; align-items:center;
      font-size: clamp(20px, 5.6vw, 42px);
      line-height: 1; cursor: pointer;
      min-width: 0; min-height: 0; /* 破綻防止 */
    }
    .cell.light{ background: var(--light); color:#111; }
    .cell.dark { background: var(--dark); }
    .piece{
      font-family: "Segoe UI Symbol","Apple Color Emoji","Noto Color Emoji", system-ui, sans-serif;
      filter: drop-shadow(0 1px 0 rgba(0,0,0,.25));
      transform: translateZ(0);
      will-change: transform;
    }
    .w { color: #111; } /* 白駒（見やすさ優先で黒っぽく） */
    .b { color: #fff; }

    .coord{ position:absolute; font-size:10px; opacity:.7; }
    .coord.x{ left:4px; top:2px; }
    .coord.y{ right:4px; bottom:2px; }

    .cell.selected{ outline: 3px solid #f59e0b; outline-offset:-3px; }
    .cell.move::after, .cell.capture::after{
      content:''; position:absolute; inset:0; pointer-events:none;
      box-shadow: inset 0 0 0 3px rgba(34,211,238,.85);
      border-radius: 0;
    }
    .cell.capture::after{ box-shadow: inset 0 0 0 3px rgba(244,63,94,.85); }

    .panel{
      background: var(--card); border:1px solid var(--border); border-radius:14px; padding:12px;
    }
    .panel h3{ margin:.2rem 0 0.6rem; font-size:1rem; }
    .panel ul{ margin:.2rem 0 .2rem 1.2rem; color:var(--muted); font-size:.9rem; }
    .legend{ margin-top:.6rem; display:flex; gap:12px; color:var(--muted); font-size:.9rem; align-items:center; }
    .kbd{ font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: color-mix(in oklab, var(--card), var(--bg) 30%); padding:.1rem .35rem; border-radius:6px; border:1px solid var(--border); }

    .status { margin-left: 12px; padding:.25rem .5rem; border-radius:8px; background: color-mix(in oklab, var(--card), var(--bg) 30%); border:1px solid var(--border); }
    .won { color:#16a34a; }
  </style>
</head>
<body>
  <header>
    <div class="left">
      <button id="newGameBtn" class="btn">新しい対局</button>
      <label class="chk"><input type="checkbox" id="showCoords" checked> 座標表示</label>
      <span id="variantMeta" class="status">Q/K固定・線対称・ポーンも入替</span>
    </div>
    <div class="right">
      <span id="turnInfo">白の手番</span>
    </div>
  </header>

  <main class="wrap">
    <div id="board" class="board" aria-label="チェス盤 8x8"></div>
    <aside class="panel">
      <h3>ルール（このバリアント）</h3>
      <ul>
        <li>初期配置は「王（e1/e8）とクイーン（d1/d8）」を固定。</li>
        <li>その他（R,N,B,P）全ては、<strong>白の1段目の残り6マス＋2段目の8マス（計14マス）</strong>にランダム再配置。</li>
        <li>相手側は<strong>上下の線対称</strong>に、同じファイル・同じ列の位置へ同種を配置。</li>
        <li>基本の指し方は通常のチェスと同じ（簡易版：チェック/メイト・キャスリング・アンパッサンなし、昇格は自動でQ）。</li>
      </ul>
      <details>
        <summary>補足</summary>
        <ul>
          <li>ポーンが1段目に来る場合があるが、その場合の2歩は不可（通常の開始段のみ2歩可）。</li>
          <li>キングを取った時点で勝敗確定。</li>
        </ul>
      </details>
      <div class="legend">
        <span>白: ♔♕♖♗♘♙</span>
        <span>黒: ♚♛♜♝♞♟</span>
        <span class="kbd">N</span> 新しい対局
      </div>
    </aside>
  </main>

  <script>
  (function(){
    'use strict';
    function ready(fn){ if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', fn, {once:true}); } else { fn(); } }

    ready(() => {
      const boardEl = document.getElementById('board');
      const newBtn = document.getElementById('newGameBtn');
      const showCoordsChk = document.getElementById('showCoords');
      const turnInfo = document.getElementById('turnInfo');

      if(!boardEl){ console.error('[chess] #board not found'); return; }

      const WHITE='w', BLACK='b';
      const size = 8;

      const PIECE_CHAR = {
        w: { K:'\u2654', Q:'\u2655', R:'\u2656', B:'\u2657', N:'\u2658', P:'\u2659' },
        b: { K:'\u265A', Q:'\u265B', R:'\u265C', B:'\u265D', N:'\u265E', P:'\u265F' },
      };

      const state = {
        board: emptyBoard(),
        turn: WHITE,
        selected: null, // {x,y}
        moves: [],      // {x,y,capture:boolean}
        gameOver: false,
      };

      function emptyBoard(){
        return Array.from({length:size}, ()=> Array.from({length:size}, ()=> null));
      }
      function clonePiece(p){ return p ? {...p} : null; }
      function placePiece(board, x,y, piece){ board[y][x] = piece ? clonePiece(piece) : null; }

      function sideToMove(){ return state.turn; }
      function otherSide(s){ return s===WHITE ? BLACK : WHITE; }

      function render(){
        boardEl.innerHTML = '';
        for(let y=0; y<size; y++){
          for(let x=0; x<size; x++){
            const cell = document.createElement('div');
            cell.className = 'cell ' + (((x+y)&1) ? 'dark':'light');
            cell.dataset.x = x;
            cell.dataset.y = y;

            if(showCoordsChk.checked){
              const cx = document.createElement('div');
              cx.className='coord x';
              cx.textContent = String.fromCharCode(65 + x); // A..H
              const cy = document.createElement('div');
              cy.className='coord y';
              cy.textContent = (8 - y);
              cell.appendChild(cx); cell.appendChild(cy);
            }

            const p = state.board[y][x];
            if(p){
              const el = document.createElement('div');
              el.className = 'piece ' + p.side;
              el.textContent = PIECE_CHAR[p.side][p.type];
              cell.appendChild(el);
            }

            if(state.selected && state.selected.x===x && state.selected.y===y){
              cell.classList.add('selected');
            }
            if(state.moves.some(m=>m.x===x && m.y===y)){
              const cap = state.board[y][x] && state.board[y][x].side !== sideToMove();
              cell.classList.add(cap ? 'capture' : 'move');
            }

            cell.addEventListener('click', onCellClick);
            boardEl.appendChild(cell);
          }
        }
        turnInfo.textContent = state.gameOver
          ? (state.turn===WHITE ? '黒の勝ち' : '白の勝ち')
          : (state.turn===WHITE ? '白の手番' : '黒の手番');
        if(state.gameOver){
          turnInfo.classList.add('won');
        }else{
          turnInfo.classList.remove('won');
        }
      }

      function onCellClick(e){
        if(state.gameOver) return;
        const x = parseInt(e.currentTarget.dataset.x,10);
        const y = parseInt(e.currentTarget.dataset.y,10);
        const p = state.board[y][x];

        if(state.selected){
          const ok = state.moves.some(m=>m.x===x && m.y===y);
          if(ok){
            moveSelectedTo(x,y);
            return;
          }
        }
        if(p && p.side === sideToMove()){
          state.selected = {x,y};
          state.moves = generateMoves(x,y);
        } else {
          state.selected = null;
          state.moves = [];
        }
        render();
      }

      function moveSelectedTo(tx,ty){
        const {x,y} = state.selected;
        const piece = state.board[y][x];
        const target = state.board[ty][tx];

        // 勝敗（キング捕獲）判定
        if(target && target.type === 'K'){
          placePiece(state.board, tx, ty, piece);
          placePiece(state.board, x, y, null);
          state.gameOver = true;
          state.selected = null;
          state.moves = [];
          render();
          return;
        }

        // ポーン昇格（最終段到達で自動昇格：Q）
        if(piece.type === 'P'){
          placePiece(state.board, tx, ty, piece);
          placePiece(state.board, x, y, null);
          const lastRank = (piece.side===WHITE ? 0 : 7);
          if(ty === lastRank){
            state.board[ty][tx].type = 'Q';
          }
        }else{
          placePiece(state.board, tx, ty, piece);
          placePiece(state.board, x, y, null);
        }

        state.selected = null;
        state.moves = [];
        state.turn = otherSide(state.turn);
        render();
      }

      // --------- 初期配置（バリアント生成） ---------
      // Q/K固定、他（R,N,B,P）を1段目の残り6マス＋2段目8マスにランダム配置。
      // 黒側は上下線対称（(x,y) -> (x,7-y)）で同種配置。
      function generateVariant(){
        const b = emptyBoard();

        // 白の固定：Q(d1)= (3,7) / K(e1)= (4,7)
        placePiece(b, 3, 7, {type:'Q', side:WHITE});
        placePiece(b, 4, 7, {type:'K', side:WHITE});

        // ランダム対象マス（白側計14マス）
        const positions = [];
        // back rank (y=7) except d,e
        for(let x=0;x<8;x++){ if(x!==3 && x!==4) positions.push({x, y:7}); }
        // pawn rank (y=6) all 8 files
        for(let x=0;x<8;x++){ positions.push({x, y:6}); }

        // プール：R,R,N,N,B,B + P×8
        const pool = ['R','R','N','N','B','B', 'P','P','P','P','P','P','P','P'];
        shuffleInPlace(pool);

        // 白に割当
        positions.forEach((pos,i)=>{
          placePiece(b, pos.x, pos.y, {type: pool[i], side:WHITE});
        });

        // 黒は上下線対称に同種配置（Q/K含む）
        for(let y=6;y<=7;y++){
          for(let x=0;x<8;x++){
            const wp = b[y][x];
            if(wp){
              const my = 7 - y;
              placePiece(b, x, my, {type: wp.type, side:BLACK});
            }
          }
        }

        return b;
      }

      function startNewGame(){
        state.board = generateVariant();
        state.turn = WHITE;
        state.selected = null;
        state.moves = [];
        state.gameOver = false;
        render();
      }

      // --------- 動きの生成（簡易版：チェック判定/城/アンパッサンなし） ---------
      function generateMoves(x,y){
        const b = state.board;
        const p = b[y][x];
        if(!p) return [];
        const moves = [];

        function pushStep(nx,ny){
          if(nx<0||nx>=8||ny<0||ny>=8) return false;
          const t = b[ny][nx];
          if(!t){ moves.push({x:nx,y:ny,capture:false}); return true; }
          if(t.side !== p.side){ moves.push({x:nx,y:ny,capture:true}); }
          return false;
        }
        function slide(dx,dy){
          let nx=x+dx, ny=y+dy;
          while(nx>=0&&nx<8&&ny>=0&&ny<8){
            const cont = pushStep(nx,ny);
            if(!cont) break;
            const has = b[ny][nx] != null;
            if(has) break;
            nx+=dx; ny+=dy;
          }
        }

        switch(p.type){
          case 'N': {
            const deltas = [[1,2],[2,1],[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2]];
            deltas.forEach(([dx,dy])=>{
              const nx=x+dx, ny=y+dy;
              if(nx<0||nx>=8||ny<0||ny>=8) return;
              const t=b[ny][nx];
              if(!t || t.side!==p.side) moves.push({x:nx,y:ny,capture:!!t});
            });
            break;
          }
          case 'B': slide(1,1); slide(1,-1); slide(-1,1); slide(-1,-1); break;
          case 'R': slide(1,0); slide(-1,0); slide(0,1); slide(0,-1); break;
          case 'Q': slide(1,0); slide(-1,0); slide(0,1); slide(0,-1); slide(1,1); slide(1,-1); slide(-1,1); slide(-1,-1); break;
          case 'K': {
            for(let dx=-1; dx<=1; dx++){
              for(let dy=-1; dy<=1; dy++){
                if(dx===0 && dy===0) continue;
                const nx=x+dx, ny=y+dy;
                if(nx<0||nx>=8||ny<0||ny>=8) continue;
                const t=b[ny][nx];
                if(!t || t.side!==p.side) moves.push({x:nx,y:ny,capture:!!t});
              }
            }
            break;
          }
          case 'P': {
            const dir = (p.side===WHITE ? -1 : 1);
            const startRank = (p.side===WHITE ? 6 : 1);
            const oneY = y + dir;
            // 1歩
            if(inBoard(x, oneY) && !b[oneY][x]){
              moves.push({x:x, y:oneY, capture:false});
              // 2歩（開始段のみ）
              const twoY = y + 2*dir;
              if(y===startRank && inBoard(x,twoY) && !b[twoY][x]){
                moves.push({x:x, y:twoY, capture:false});
              }
            }
            // 斜め取り
            for(const dx of [-1, 1]){
              const nx = x + dx, ny = y + dir;
              if(!inBoard(nx,ny)) continue;
              const t = b[ny][nx];
              if(t && t.side !== p.side) moves.push({x:nx, y:ny, capture:true});
            }
            break;
          }
        }
        return moves;
      }

      function inBoard(x,y){ return x>=0 && x<8 && y>=0 && y<8; }

      function shuffleInPlace(a){
        for(let i=a.length-1;i>0;i--){
          const j=(Math.random()*(i+1))|0;
          [a[i],a[j]] = [a[j],a[i]];
        }
      }

      // Controls
      newBtn.addEventListener('click', startNewGame);
      showCoordsChk.addEventListener('change', render);
      window.addEventListener('keydown', (e)=>{
        if(e.key==='n' || e.key==='N'){ startNewGame(); }
      });

      // 初期開始
      startNewGame();
    });
  })();
  </script>
</body>
</html>
